# Avian

## Overview

This project implements a **lexical analyzer** (scanner) for a custom **Mini C++-like language** named **Avian**, developed using **Flex (Fast Lexical Analyzer Generator)**.

The scanner forms the **first phase** of the compiler construction process. It reads source code written in the Avian language and breaks it down into **tokens** — identifiers, keywords, numbers, operators, strings, punctuations, and symbols — that can later be used by the parser and semantic analyzer.

This implementation focuses on correctness, originality, and realism according to the official rubric for Compiler Construction Project Phase 1.

---

## Table of Contents

1. [Project Structure](#project-structure)
2. [Language Design](#language-design)
3. [Language Philosophy](#language-philosophy)
4. [Features](#features)
5. [Installation and Setup](#installation-and-setup)
6. [Building and Running the Scanner](#building-and-running-the-scanner)
7. [Sample Program](#sample-program)
8. [Example Output](#example-output)
9. [Error Handling Examples](#error-handling-examples)
10. [Documentation Includes](#documentation-includes)
11. [Future Work (Phase 2 and Beyond)](#future-work-phase-2-and-beyond)

---

## Project Structure

```
/avian-compiler/
│
├── scanner.l              # Flex source file (Avian language scanner)
├── avian_sample.avn       # Sample test program in Avian language
├── tokens.txt             # Tokenized output generated by the scanner
├── error.log              # Lexical error report file
├── README.md              # Documentation file (this file)
└── docs/
    ├── video.mp4    # execution video
    └── regex_def.pdf    # Identifier and Number FA diagrams and regex definitions for all tokens
```

---

## Language Design

### Keywords (15 total)

```
avn_if, avn_else, avn_for, avn_while, avn_break, avn_continue, avn_cin, avn_cout, avn_return, avn_print, avn_int, avn_float, avn_str, avn_main, avn_end
```

### Custom Operators (6 total)

| Operator | Description    |
| -------- | -------------- |
| `_+_`    | Addition       |
| `_-_`    | Subtraction    |
| `_*_`    | Multiplication |
| `_/ _`   | Division       |
| `_++_`   | Increment      |
| `_--_`   | Decrement      |

### Custom Punctuations (3 total)

| Symbol | Description                        |
| ------ | ---------------------------------- |
| `_,_`  | Comma separator                    |
| `;`   | Statement terminator               |
| `::`   | Section divider or scope separator |

---

## Language Philosophy

The word **Avian** literally means "related to birds" and just like that, the language draws its name and concept from birds.
Just as birds communicate in complex patterns and sounds that humans may not understand — yet they perfectly understand each other — *Avian* represents a similar philosophy in programming language design.

Although Avian is built on C++ syntax, its unique keywords and operators transform it into a distinct system of communication between the human and the compiler.

The goal is to demonstrate that:

* Language is not defined by the symbols themselves but by the **rules** that interpret them.
* A compiler can understand any structured language if its lexical and syntactical rules are clearly defined.

In short:

> Humans may not immediately understand the syntax of Avian,
> but the compiler can — just as birds understand one another.

---

## Features

### 1. Tokenization

The scanner identifies and classifies the following categories:

* **Keywords** (custom `avn_` prefixed words)
* **Identifiers**
* **Integers, floats, exponential numbers**
* **Operators (custom and default)**
* **Strings**
* **Punctuations**

### 2. Comment Handling

* **Single-line comments:** `// comment`
* **Multi-line comments:** `/* block comment */`

Comments are ignored by the scanner.

### 3. Error Handling

Unrecognized or invalid characters are reported in `error.log` with their respective line numbers.

**Example:**

```
Line 4: ERROR → @invalid
```

### 4. Line Tracking

Each token is printed with its **line number**, type, and value in the following format:

```
Line 3: KEYWORD              → avn_int
Line 3: IDENTIFIER           → a
Line 3: ASSIGN_OP            → =
Line 3: INTEGER              → 10
```

### 5. Realistic Token Coverage

The scanner includes both **custom Avian operators** and **default Mini C++ tokens** such as:

```
=, +, -, *, /, (, ), {, }, ,, ;, <, >, ==, !=
```

This ensures compatibility with real-world programming syntax.

---

## Installation and Setup

### Step 1 — Install Required Packages

```bash
sudo apt update
sudo apt install flex gcc
```

### Step 2 — Verify Installation

```bash
flex --version
gcc --version
```

Expected output includes version numbers for both Flex and GCC.

---

## Building and Running the Scanner

### Step 1 — Generate C Code from Flex

```bash
flex scanner.l
```

### Step 2 — Compile the Generated Code

```bash
gcc lex.yy.c -lfl -o avian_scanner
```

### Step 3 — Run the Scanner

To scan interactively:

```bash
./avian_scanner
```

To scan a file:

```bash
./avian_scanner < avian_sample.avn > tokens.txt 2> error.log
```

### Step 4 — View Results

* **tokens.txt** — recognized tokens with line numbers
* **error.log** — lexical errors and unclosed comment reports

---

## Sample Program (`avian_sample.avn`)

```
avn_func avn_int avn_main;'
avn_int a = 10;'
avn_int b = 5;'
avn_int sum;'
avn_int prod;'

avn_if (a _-_ b) {
    avn_print "Positive difference";'
}
avn_else {
    avn_print "Zero or negative";'
}

sum = a _+_ b;'
prod = a _*_ b;'
avn_print "Sum:" _,_ sum;'
avn_print "Product:" _,_ prod;'
avn_end;'
avn_return 0;'
```

---

## Example Output (`tokens.txt`)

```
Line 1: KEYWORD              → avn_func
Line 1: KEYWORD              → avn_int
Line 1: KEYWORD              → avn_main
Line 2: KEYWORD              → avn_int
Line 2: IDENTIFIER           → a
Line 2: ASSIGN_OP            → =
Line 2: INTEGER              → 10
Line 2: PUNC_SEMI_APOS       → ;'
Line 3: KEYWORD              → avn_int
Line 3: IDENTIFIER           → b
Line 3: ASSIGN_OP            → =
Line 3: INTEGER              → 5
Line 3: PUNC_SEMI_APOS       → ;'
...
Line 12: KEYWORD             → avn_end
Line 13: KEYWORD             → avn_return
Line 13: INTEGER             → 0
Line 13: PUNC_SEMI_APOS      → ;'
```

---

## Error Handling Examples

**Invalid Symbol**

```
avn_int $value;'
```

**Output:**

```
Line 1: ERROR → $
```

**Unclosed Comment**

```
/* missing end
avn_int x;'
```

**Output:**

```
Line 2: ERROR → unclosed comment
```

---

## Documentation Includes

### 1. Regex Definitions Table

Include a detailed table listing all regex patterns used to identify:

* Identifiers
* Numbers (integer, float, exponential)
* Keywords
* Operators
* Punctuations
* Strings

### 2. Finite Automata Diagrams

Provided FA diagrams for:

* **Identifiers**
* **Numbers (integers and floats)**

### 3. Keyword and Operator Explanation

All keywords in Avian share the `avn_` prefix to make them easily distinguishable from identifiers, simplify regex patterns, streamline FA design through a shared starting path, and maintain a consistent, readable, C++-like structure. It keeps every reserved word distinct, easy to detect, and ensures consistent token recognition across the language.

---

## Future Work (Phase 2 and Beyond)

The Avian language lexical analyzer will serve as the foundation for subsequent compiler phases, including:

**Syntax Analysis (Parser)**
   Using grammar rules and syntax-directed translation.
2. **Semantic Analysis**
   Type checking, scope resolution, and symbol table construction.
3. **Intermediate Code Generation**
   Translating source code into an intermediate representation.
4. **Code Optimization and Final Output**
   Producing efficient and executable machine-level code.

This project demonstrates the foundational concept that a consistent lexical structure allows any symbolic language — to be analyzed and interpreted by a compiler.
