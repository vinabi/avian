# Avian

## Overview

This project implements a **lexical analyzer** (scanner) for a custom **Mini C++-like language** named **Avian**, developed using **Flex (Fast Lexical Analyzer Generator)**.

The scanner forms the **first phase** of the compiler construction process. It reads source code written in the Avian language and breaks it down into **tokens** â€” identifiers, keywords, numbers, operators, strings, punctuations, and symbols â€” that can later be used by the parser and semantic analyzer.

This implementation focuses on correctness, originality, and realism according to the official rubric for Compiler Construction Project Phase 1.

---

## Table of Contents
ðŸ˜­ okay okay. Clean. Normal. No drama.

## Table of Contents

   [Overview](#overview)
   [Project Structure](#project-structure)
1. [Phase 1 Lexical Analyzer](#phase-1-lexical-analyzer)
   Â Â 1.1 [Language Design](#language-design)
   Â Â 1.2 [Language Philosophy](#language-philosophy)
   Â Â 1.3 [Features](#features)
   Â Â 1.4 [Installation and Setup](#installation-and-setup)
   Â Â 1.5 [Building and Running the Scanner](#building-and-running-the-scanner)
   Â Â 1.6 [Sample Program](#sample-program-avian_sampleavn)
   Â Â 1.7 [Example Output](#example-output-tokenstxt)
   Â Â 1.8 [Error Handling Examples](#error-handling-examples)
   Â Â 1.9 [Documentation Includes](#documentation-includes)
2. [Phase 2 Syntax Analysis](#phase-2--syntax-analysis-parser)
   Â Â 2.1 [Overview](#overview-1)
   Â Â 2.2 [Role of Phase 2 in the Compiler](#role-of-phase-2-in-the-compiler)
   Â Â 2.3 [Grammar Design](#grammar-design-cfg)
   Â Â 2.4 [FIRST and FOLLOW Sets](#first-and-follow-sets-dragon-book-style)
   Â Â 2.5 [Parse Tree Construction](#parse-tree-construction)
   Â Â 2.6 [Parser Implementation](#parser-implementation)
   Â Â 2.7 [Error Handling](#error-handling)
   Â Â 2.8 [Building and Running the Parser](#building-and-running-the-parser)
   Â Â 2.9 [Test Programs](#test-programs)
   Â Â 2.10 [Phase 2 Outcome](#phase-2-outcome)


---

## Project Structure

```
/avian-compiler/
â”‚
â”œâ”€â”€ scanner.l              # Flex source file (Avian language scanner)
â”œâ”€â”€ avian_sample.avn       # Sample test program in Avian language
â”œâ”€â”€ tokens.txt             # Tokenized output generated by the scanner
â”œâ”€â”€ error.log              # Lexical error report file
â”œâ”€â”€ README.md              # Documentation file (this file)
â””â”€â”€ docs/
    â”œâ”€â”€ video.mp4    # execution video
    â””â”€â”€ regex_def.pdf    # Identifier and Number FA diagrams and regex definitions for all tokens
```

---

## Language Design

### Keywords (15 total)

```
avn_if, avn_else, avn_for, avn_while, avn_break, avn_continue, avn_cin, avn_cout, avn_return, avn_print, avn_int, avn_float, avn_str, avn_main, avn_end
```

### Custom Operators (6 total)

| Operator | Description    |
| -------- | -------------- |
| `_+_`    | Addition       |
| `_-_`    | Subtraction    |
| `_*_`    | Multiplication |
| `_/ _`   | Division       |
| `_++_`   | Increment      |
| `_--_`   | Decrement      |

### Custom Punctuations (3 total)

| Symbol | Description                        |
| ------ | ---------------------------------- |
| `_,_`  | Comma separator                    |
| `;`   | Statement terminator               |
| `::`   | Section divider or scope separator |

---

## Language Philosophy

The word **Avian** literally means "related to birds" and just like that, the language draws its name and concept from birds.
Just as birds communicate in complex patterns and sounds that humans may not understand â€” yet they perfectly understand each other â€” *Avian* represents a similar philosophy in programming language design.

Although Avian is built on C++ syntax, its unique keywords and operators transform it into a distinct system of communication between the human and the compiler.

The goal is to demonstrate that:

* Language is not defined by the symbols themselves but by the **rules** that interpret them.
* A compiler can understand any structured language if its lexical and syntactical rules are clearly defined.

In short:

> Humans may not immediately understand the syntax of Avian,
> but the compiler can â€” just as birds understand one another.

---

## Features

### 1. Tokenization

The scanner identifies and classifies the following categories:

* **Keywords** (custom `avn_` prefixed words)
* **Identifiers**
* **Integers, floats, exponential numbers**
* **Operators (custom and default)**
* **Strings**
* **Punctuations**

### 2. Comment Handling

* **Single-line comments:** `// comment`
* **Multi-line comments:** `/* block comment */`

Comments are ignored by the scanner.

### 1. Error Handling

Unrecognized or invalid characters are reported in `error.log` with their respective line numbers.

**Example:**

```
Line 4: ERROR â†’ @invalid
```

### 2. Line Tracking

Each token is printed with its **line number**, type, and value in the following format:

```
Line 3: KEYWORD              â†’ avn_int
Line 3: IDENTIFIER           â†’ a
Line 3: ASSIGN_OP            â†’ =
Line 3: INTEGER              â†’ 10
```

### 5. Realistic Token Coverage

The scanner includes both **custom Avian operators** and **default Mini C++ tokens** such as:

```
=, +, -, *, /, (, ), {, }, ,, ;, <, >, ==, !=
```

This ensures compatibility with real-world programming syntax.

---

## Installation and Setup

### Step 1 â€” Install Required Packages

```bash
sudo apt update
sudo apt install flex gcc
```

### Step 2 â€” Verify Installation

```bash
flex --version
gcc --version
```

Expected output includes version numbers for both Flex and GCC.

---

## Building and Running the Scanner

### Step 1 â€” Generate C Code from Flex

```bash
flex scanner.l
```

### Step 2 â€” Compile the Generated Code

```bash
gcc lex.yy.c -lfl -o avian_scanner
```

### Step 3 â€” Run the Scanner

To scan interactively:

```bash
./avian_scanner
```

To scan a file:

```bash
./avian_scanner < avian_sample.avn > tokens.txt 2> error.log
```

### Step 4 â€” View Results

* **tokens.txt** â€” recognized tokens with line numbers
* **error.log** â€” lexical errors and unclosed comment reports

---

## Sample Program (`avian_sample.avn`)

```
avn_func avn_int avn_main;'
avn_int a = 10;'
avn_int b = 5;'
avn_int sum;'
avn_int prod;'

avn_if (a _-_ b) {
    avn_print "Positive difference";'
}
avn_else {
    avn_print "Zero or negative";'
}

sum = a _+_ b;'
prod = a _*_ b;'
avn_print "Sum:" _,_ sum;'
avn_print "Product:" _,_ prod;'
avn_end;'
avn_return 0;'
```

---

## Example Output (`tokens.txt`)

```
Line 1: KEYWORD              â†’ avn_func
Line 1: KEYWORD              â†’ avn_int
Line 1: KEYWORD              â†’ avn_main
Line 2: KEYWORD              â†’ avn_int
Line 2: IDENTIFIER           â†’ a
Line 2: ASSIGN_OP            â†’ =
Line 2: INTEGER              â†’ 10
Line 2: PUNC_SEMI_APOS       â†’ ;'
Line 3: KEYWORD              â†’ avn_int
Line 3: IDENTIFIER           â†’ b
Line 3: ASSIGN_OP            â†’ =
Line 3: INTEGER              â†’ 5
Line 3: PUNC_SEMI_APOS       â†’ ;'
...
Line 12: KEYWORD             â†’ avn_end
Line 13: KEYWORD             â†’ avn_return
Line 13: INTEGER             â†’ 0
Line 13: PUNC_SEMI_APOS      â†’ ;'
```

---

## Error Handling Examples

**Invalid Symbol**

```
avn_int $value;'
```

**Output:**

```
Line 1: ERROR â†’ $
```

**Unclosed Comment**

```
/* missing end
avn_int x;'
```

**Output:**

```
Line 2: ERROR â†’ unclosed comment
```

---

## Documentation Includes

### 1. Regex Definitions Table

Include a detailed table listing all regex patterns used to identify:

* Identifiers
* Numbers (integer, float, exponential)
* Keywords
* Operators
* Punctuations
* Strings

### 2. Finite Automata Diagrams

Provided FA diagrams for:

* **Identifiers**
* **Numbers (integers and floats)**

### 1. Keyword and Operator Explanation

All keywords in Avian share the `avn_` prefix to make them easily distinguishable from identifiers, simplify regex patterns, streamline FA design through a shared starting path, and maintain a consistent, readable, C++-like structure. It keeps every reserved word distinct, easy to detect, and ensures consistent token recognition across the language.

---

# Phase 2 â€” Syntax Analysis (Parser)

## Overview

Phase 2 extends the Avian compiler by implementing a **syntax analyzer (parser)** using **YACC / Bison**, following the principles of compiler design. While Phase 1 focused on breaking the source program into tokens, Phase 2 focuses on **verifying the grammatical structure** of those tokens using a **Context-Free Grammar (CFG)**.The parser ensures that programs written in the Avian language follow valid syntactic rules before moving to later compilation phases.

---

## Role of Phase 2 in the Compiler

Phase 2 performs **syntax analysis**, which means:

* Checking whether the sequence of tokens produced by the scanner is grammatically valid
* Ensuring correct statement structure
* Detecting and reporting syntax errors with line numbers
* Conceptually constructing a parse tree for valid programs

This phase does **not** perform semantic analysis or code generation.

---

## Grammar Design (CFG)

The Avian grammar is designed using **Dragon Book conventions**, with short non-terminals and clear structure.

### Start Symbol

```
P
```

### Grammar Rules

```
P  â†’ B

B  â†’ { SL }

SL â†’ S SL | Îµ

S  â†’ D | A | IF | WH | OUT

D  â†’ avn_int id ;

A  â†’ id = num ;

IF â†’ avn_if ( num ) B
    | avn_if ( num ) B avn_else B

WH â†’ avn_while ( num ) B

OUT â†’ avn_print id ;
```

This grammar supports all mandatory constructs required by the Phase 2 rubric:

* Program structure
* Variable declaration
* Assignment
* Conditional statements
* Loop statements
* Output statements

---

## FIRST and FOLLOW Sets (Dragon Book Style)

### FIRST Sets

```
FIRST(S)  = { avn_int, id, avn_if, avn_while, avn_print }
FIRST(SL) = { avn_int, id, avn_if, avn_while, avn_print, Îµ }
```

### FOLLOW Sets

```
FOLLOW(P)  = { $ }
FOLLOW(SL) = { }, $ }
FOLLOW(S)  = { avn_int, id, avn_if, avn_while, avn_print, }, $ }
```

These sets are used during grammar analysis to ensure correct parsing behavior and error detection.

---

## Parse Tree Construction

For a valid Avian program fragment:

```
{
  avn_int a;
  a = 5;
  avn_if (1) { avn_print a; }
}
```

A fully expanded **parse tree** can be constructed based on the grammar rules, showing how the program derives from the start symbol `P`.

The parse tree is **documented manually** (hand-drawn), as required by the project rubric.
The parser itself does not print the parse tree during execution.

---

## Parser Implementation

The parser is implemented using **Bison**, and it is tightly integrated with the Phase 1 scanner.

### Key Characteristics

* Reuses **all tokens** defined in `scanner.l`
* Uses `%token` declarations to share tokens between scanner and parser
* Implements grammar rules exactly as defined in the CFG
* Reports syntax errors using `yyerror()`
* Prints a success message if parsing completes without errors

---

## Error Handling

The parser detects and reports syntax errors such as:

* Missing semicolons
* Missing parentheses
* Invalid statement structure

### Example Error Output

```
Syntax Error at line 4: expected ';' but found '}'
```

Each error message includes:

* Line number
* Nature of error
* Found token

---

## Building and Running the Parser

### Required Tools

* Flex
* Bison
* GCC

### Build Commands

```bash
flex scanner.l
bison -dy parser.y
gcc lex.yy.c y.tab.c -o avian_parser
```

### Run the Parser

```bash
./avian_parser < avian_sample.avn
```

### Successful Output

```
Syntax analysis successful
```

---

## Test Programs

### Valid Program

* Includes declaration, assignment, conditional, and output
* Parsed successfully

### Invalid Program

* Contains missing or incorrect tokens
* Parser reports syntax error with line number

---

## Phase 2 Outcome

By the end of Phase 2, the Avian compiler is capable of:

* Validating complete Avian programs syntactically
* Detecting grammar violations
* Preparing the code structure for semantic analysis

This phase demonstrates the practical application of **CFGs, FIRST/FOLLOW sets, and parsing theory**.
